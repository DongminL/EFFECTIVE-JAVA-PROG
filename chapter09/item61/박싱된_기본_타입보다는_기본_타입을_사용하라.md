자바의 데이터 타입은 크게 두 가지로 나뉜다.
1. 기본 타입 (`int`, `double`, `boolean`)
2. 참조 타입 (`String`, `List`)
그리고 각각의 기본 타입에 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다.

현재는 오토박싱과 오토언박싱 덕분에 두 타입을 구분하지 않고 사용할 수는 있지만, 그렇다고 차이가 사라지는 것은 아니다.

둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.

## 기본 타입과 박싱된 기본 타입의 차이점
### 1. 기본타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다.
- 박싱된 기본 타입의 두 인스턴스 값이 같아도 서로 다르다고 식별될 수 있다.

### 2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.

### 3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

`Integer`로 값을 오름차순 정렬하는 비교자
`compare`메서드는 첫 번째 원소가 두 번째 원소보다 작으면 음수, 같으면 0, 크면 양수를 반환한다.

```java
Comparator<Integer> naturalOrder =  
        (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

int result = naturalOrder.compare(new Integer(42), new Integer(42));  
System.out.println(result); // 1
```
42와 42를 비교하면 0이 나와야 하는데 1이 나온다.

**원인은 뭘까?**
첫 번째 검사 `(i < j)`는 잘 작동한다. 여기서 `i`와 `j`가 참조하는 오토박싱된 `Integer` 인스턴스는 기본 타입값으로 변환된다.

두 번째 검사 `(i == j)`에서 문제가 발생한다.  
여기서 객체 참조의 식별성을 검사하는데 서로 다른 `Integer` 인스턴스라면 `false`가 되고, 비교자는 1을 반환한다.

실무에서 이와 같이 기본 타입을 디루는 비교자가 필요하다면 `Comparator.naturalOrder()`를 사용하자.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {  
    int i = iBoxed, j = jBoxed; // 오토박싱  
    return i < j ? -1 : (i == j ? 0 : 1);  
};

int result = naturalOrder.compare(new Integer(42), new Integer(42));  
System.out.println(result); // 0
```
위의 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 `Integer` 매개변수의 값을 기본 타입 정수로 저장한 다음 비교를 수행한다.

---

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("믿을 수 없군!");
    }
}
```
여기서 `i`는 다른 참조 타입 필드와 마찬가지로 초기값도 `null`이다.

즉, `i == 42`는 `Integer`와 `int`를 비교하는 것이다.

거의 예외 없이 기본 타입과 박시오딘 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.  
그리고 `null` 참조를 언박싱하면 `NPE`가 발생하게 된다.

해법은 `i`를 `int`로 선언해주면 된다.

---
```java
Long sum = 0L;
for (long i = 0; i <= Integer.MAX_VALUE; i++)
	sum += i;

System.out.println(sum);
```
이 프로그램은 실수로 지역변수 `sum`을 박싱된 기본 타입으로 선언하여 느려졌다.

오류나 경고 없이 컴파일되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

이번 아이템에서 다룬 세 프로그램 모두 문제의 원인은 하나다.

프로그래머가 기본 타입과 박싱된 기본 타입의 차이를 무시한 대가를 치른 것이다.

### 박싱된 기본 타입의 올바른 사용법
#### 1. 컬렉션의 원소, 키, 값으로 쓴다.
- 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.
- 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.
#### 2. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 정리
- 가능하다면 기본 타입을 사용하라.
- 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
- 오토박싱이 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
- `==` 연산자로 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며 `NPE`가 발생할 수 있다.
- 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다.
