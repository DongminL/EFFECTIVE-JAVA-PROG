# Item 62. 다른 타입이 적절하다면 문자열 사용을 피하라

## 문자열은 다른 값 타입을 대신하기에 적합하지 않다

많은 사람들이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용한다. 어쩌면 자연스럽게 생각할 수 있지만, **입력받을 데이터가 진짜 문자열일 때만 그렇게 하는 것이 좋다**.

- **받은 데이터가 수치형이면 `int`, `float`, `BigInteger` 등 적당한 수치 타입으로 변환**해야 한다.

- '예/아니오' 질문의 답이라면 적절한 **열거 타입이나 `boolean`으로 변환**해야 한다.

즉, **기본 타입이든, 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 하나 작성해라**.

<br>

## 문자열은 열거 타입을 대신하기에 적합하지 않다

아이템 34에서 이야기했듯이, **상수를 열거할 때는 문자열보다는 열거 타입이 훨씬 낫다**.

<br>

## 문자열은 혼합 타입을 대신하기에 적합하지 않다

여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.

``` java
String compundKey = className + "#" + i.next();
```

이 방식은 단점이 많다. 

- 만약 두 요소를 구분해주는 **문자 #이 두 요소 중 하나에서 쓰였다면 예기치 못한 결과**를 초래한다.

- 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 **느리고, 귀찮고, 오류 가능성도 커진다**.

- 적절한 `equals`, `toString`, `compareTo` 메서드를 제공할 수 없으면, `String`이 제공하는 기능에만 의존해야 한다.

<br>

**차라리 전용 클래스를 새로 만드는 편이 낫다**. 이런 클래스는 보통 **private 정적 멤버 클래스로 선언**한다.

<br>

## 문자열은 권한을 표현하기에 적합하지 않다

권한(capacity)를 문자열로 표현하는 경우가 종종 있다.

### 잘못된 예시 - 스레드 지역변수 기능
---

클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별한 것이다.

``` java
public class ThreadLocal {
    private ThreadLocal() {}    // 객체 생성 불가

    // 현 스레드의 값을 키로 구분해 저장한다.
    public static void set(String key, Object value);

    // (키가 가르키는) 현 스레드의 값을 반환한다.
    public static Object get(String key);
}
```

이 방식의 문제는 **스레드 구분용 문자열 키가 전역 이름공간에서 공유된다**는 점이다. 이 방식이 **의도대로 동작하려면 각 클라이언트가 고유한 키를 제공**해야 한다.

- 만약 두 클라이언트가 서로 소통하지 못해 **같은 키를 사용하기로 결정**한다면, 의도치 않게 **같은 변수를 공유**하게 된다.

- 악의적인 클라이언트라면 **의도적으로 같은 키를 사용하여 다른 클라이언트의 값을 가져올 수 있어** **보안에도 취약**하다.

### 해결책 - 위조할 수 없는 키 사용
---

``` java
public class ThreadLocal {
    private ThreadLocal() {}    // 객체 생성 불가

    public static class Key {   // 권한
        Key() {...}
    }

    // 위조 불가능한 고유한 키를 생성한다.
    public static Key getKey() {
        return new Key();
    }

    // 현 스레드의 값을 키로 구분해 저장한다.
    public static void set(Key key, Object value);

    // (키가 가르키는) 현 스레드의 값을 반환한다.
    public static Object get(Key key);
}
```

이 방법은 앞서의 문자열 기반 API의 문제 두 가지를 모두 해결해주지만, 개선할 점이 남아있다. 

`set`과 `get`은 이제 정적 메서드일 이유가 없으니 `Key` 클래스의 인스턴스의 메서드로 바꾸면 좋다. 

또한 이렇게 하게 되면 `Key`는 더 이상 스레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 스레드 지역변수가 된다. 결과적으로 지금의 톱레벨 클래스인 `ThreadLocal`은 별달리 하는 일이 없어져 치워버리고, 중첩 클래스 `Key`의 이름을 `ThreadLocal`로 바꾸면 된다.

#### Key를 ThreadLocal로 리팩토링

``` java
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

## 마무리

**문자열을 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다**.
